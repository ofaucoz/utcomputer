<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>UTComputer: nlohmann::basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UTComputer
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">ProjetLO21</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenlohmann.html">nlohmann</a></li><li class="navelem"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></li><li class="navelem"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html">lexer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classnlohmann_1_1basic__json_1_1lexer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nlohmann::basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>lexical analysis  
 <a href="classnlohmann_1_1basic__json_1_1lexer.html#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for nlohmann::basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer:</div>
<div class="dyncontent">
<div class="center"><img src="classnlohmann_1_1basic__json_1_1lexer__coll__graph.png" border="0" usemap="#nlohmann_1_1basic__json_3_01ObjectType_00_01ArrayType_00_01StringType_00_01BooleanType_00_01NumberIntegerType_00_01NumberUnsignedType_00_01NumberFloatType_00_01AllocatorType_01_4_1_1lexer_coll__map" alt="Collaboration graph"/></div>
<map name="nlohmann_1_1basic__json_3_01ObjectType_00_01ArrayType_00_01StringType_00_01BooleanType_00_01NumberIntegerType_00_01NumberUnsignedType_00_01NumberFloatType_00_01AllocatorType_01_4_1_1lexer_coll__map" id="nlohmann_1_1basic__json_3_01ObjectType_00_01ArrayType_00_01StringType_00_01BooleanType_00_01NumberIntegerType_00_01NumberUnsignedType_00_01NumberFloatType_00_01AllocatorType_01_4_1_1lexer_coll__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a96887d6cd131e3d3a85a9d71fbdbcdf7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7">token_type</a> { <br />
&#160;&#160;<a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7a42dd1a73d072bb6bf3f494f22b15db8e">token_type::uninitialized</a>, 
<a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7a85cc1a37b0aaa52de40e72f0ed4e0c0d">token_type::literal_true</a>, 
<a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7afab1694b1b3937a079f4625fe0b6108b">token_type::literal_false</a>, 
<a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7ab7ae4c0e46d86f884677768160b26e9e">token_type::literal_null</a>, 
<br />
&#160;&#160;<a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7a2b490e8bf366b4cbe3ebd99b26ce15ce">token_type::value_string</a>, 
<a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7a70757c72c4d12f142689024dc4acb9dd">token_type::value_number</a>, 
<a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7a16c226b4425b68560fea322b46dabe01">token_type::begin_array</a>, 
<a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7a9a9ffd53b6869d4eca271b1ed5b57fe8">token_type::begin_object</a>, 
<br />
&#160;&#160;<a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7a2f3e68e7f111a1e5c7728742b3ca2b7f">token_type::end_array</a>, 
<a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7a7d5b4427866814de4d8f132721d59c87">token_type::end_object</a>, 
<a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7acc3c64f8ae08c00de1b33f19a4d2913a">token_type::name_separator</a>, 
<a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7a745373036100d7392ad62c617cab59af">token_type::value_separator</a>, 
<br />
&#160;&#160;<a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7a456e19aeafa334241c7ff3f589547f9d">token_type::parse_error</a>, 
<a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7aca11f56dd477c09e06583dbdcda0985f">token_type::end_of_input</a>
<br />
 }<tr class="memdesc:a96887d6cd131e3d3a85a9d71fbdbcdf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">token types for the parser  <a href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a96887d6cd131e3d3a85a9d71fbdbcdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7858ae971d07f21ad47fa8a0421001db"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a7858ae971d07f21ad47fa8a0421001db">lexer_char_t</a> = unsigned char</td></tr>
<tr class="memdesc:a7858ae971d07f21ad47fa8a0421001db"><td class="mdescLeft">&#160;</td><td class="mdescRight">the char type to use in the lexer  <a href="#a7858ae971d07f21ad47fa8a0421001db">More...</a><br /></td></tr>
<tr class="separator:a7858ae971d07f21ad47fa8a0421001db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4b09fcd209c514976c530257f092bcd0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a4b09fcd209c514976c530257f092bcd0">lexer</a> (const <a class="el" href="classnlohmann_1_1basic__json.html#ab63e618bbb0371042b1bec17f5891f42">string_t</a> &amp;s) noexcept</td></tr>
<tr class="memdesc:a4b09fcd209c514976c530257f092bcd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor with a given buffer  <a href="#a4b09fcd209c514976c530257f092bcd0">More...</a><br /></td></tr>
<tr class="separator:a4b09fcd209c514976c530257f092bcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7750487ca3688d91c31d87c7e7917ee0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a7750487ca3688d91c31d87c7e7917ee0">lexer</a> (std::istream *s) noexcept</td></tr>
<tr class="memdesc:a7750487ca3688d91c31d87c7e7917ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor with a given stream  <a href="#a7750487ca3688d91c31d87c7e7917ee0">More...</a><br /></td></tr>
<tr class="separator:a7750487ca3688d91c31d87c7e7917ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd79b7df4a2c6b3693648b18ce4c359c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#acd79b7df4a2c6b3693648b18ce4c359c">lexer</a> ()=default</td></tr>
<tr class="memdesc:acd79b7df4a2c6b3693648b18ce4c359c"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="#acd79b7df4a2c6b3693648b18ce4c359c">More...</a><br /></td></tr>
<tr class="separator:acd79b7df4a2c6b3693648b18ce4c359c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cd0b0203240c650de724eaa372fe20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a18cd0b0203240c650de724eaa372fe20">lexer</a> (const <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html">lexer</a> &amp;)=delete</td></tr>
<tr class="separator:a18cd0b0203240c650de724eaa372fe20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862a22693d9fadbf4a5f00207da1dd00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html">lexer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a862a22693d9fadbf4a5f00207da1dd00">operator=</a> (const <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html">lexer</a> &amp;)=delete</td></tr>
<tr class="separator:a862a22693d9fadbf4a5f00207da1dd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196879de6f3e59c98e2362fb8d401dc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7">token_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a196879de6f3e59c98e2362fb8d401dc4">scan</a> () noexcept</td></tr>
<tr class="separator:a196879de6f3e59c98e2362fb8d401dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7f5e914691aaa545ad291eb5ddc817"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a8b7f5e914691aaa545ad291eb5ddc817">yyfill</a> () noexcept</td></tr>
<tr class="memdesc:a8b7f5e914691aaa545ad291eb5ddc817"><td class="mdescLeft">&#160;</td><td class="mdescRight">append data from the stream to the internal buffer  <a href="#a8b7f5e914691aaa545ad291eb5ddc817">More...</a><br /></td></tr>
<tr class="separator:a8b7f5e914691aaa545ad291eb5ddc817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eab4ce848cefe355dd0d61f9a5348a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#ab63e618bbb0371042b1bec17f5891f42">string_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a0eab4ce848cefe355dd0d61f9a5348a0">get_token</a> () const </td></tr>
<tr class="memdesc:a0eab4ce848cefe355dd0d61f9a5348a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return string representation of last read token  <a href="#a0eab4ce848cefe355dd0d61f9a5348a0">More...</a><br /></td></tr>
<tr class="separator:a0eab4ce848cefe355dd0d61f9a5348a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18dc059f3a96af88104ca02d919c16b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#ab63e618bbb0371042b1bec17f5891f42">string_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a18dc059f3a96af88104ca02d919c16b5">get_string</a> () const </td></tr>
<tr class="memdesc:a18dc059f3a96af88104ca02d919c16b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return string value for string tokens  <a href="#a18dc059f3a96af88104ca02d919c16b5">More...</a><br /></td></tr>
<tr class="separator:a18dc059f3a96af88104ca02d919c16b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541f1cd06178fefc5ddde34022852c10"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a541f1cd06178fefc5ddde34022852c10">str_to_float_t</a> (long double *, char **endptr) const </td></tr>
<tr class="memdesc:a541f1cd06178fefc5ddde34022852c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse floating point number  <a href="#a541f1cd06178fefc5ddde34022852c10">More...</a><br /></td></tr>
<tr class="separator:a541f1cd06178fefc5ddde34022852c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d53d1c76a58b7f4d1315d44665eab3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a29d53d1c76a58b7f4d1315d44665eab3">str_to_float_t</a> (double *, char **endptr) const </td></tr>
<tr class="memdesc:a29d53d1c76a58b7f4d1315d44665eab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse floating point number  <a href="#a29d53d1c76a58b7f4d1315d44665eab3">More...</a><br /></td></tr>
<tr class="separator:a29d53d1c76a58b7f4d1315d44665eab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea092725cd2b01e84126898f080418d6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#aea092725cd2b01e84126898f080418d6">str_to_float_t</a> (float *, char **endptr) const </td></tr>
<tr class="memdesc:aea092725cd2b01e84126898f080418d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse floating point number  <a href="#aea092725cd2b01e84126898f080418d6">More...</a><br /></td></tr>
<tr class="separator:aea092725cd2b01e84126898f080418d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9787fee5177c60bbc80d9e41282e9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a3a9787fee5177c60bbc80d9e41282e9f">get_number</a> (<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;result) const </td></tr>
<tr class="memdesc:a3a9787fee5177c60bbc80d9e41282e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return number value for number tokens  <a href="#a3a9787fee5177c60bbc80d9e41282e9f">More...</a><br /></td></tr>
<tr class="separator:a3a9787fee5177c60bbc80d9e41282e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aaba589becdcea269f271466f73dbf08b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classnlohmann_1_1basic__json.html#ab63e618bbb0371042b1bec17f5891f42">string_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#aaba589becdcea269f271466f73dbf08b">to_unicode</a> (const std::size_t codepoint1, const std::size_t codepoint2=0)</td></tr>
<tr class="memdesc:aaba589becdcea269f271466f73dbf08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a string from a Unicode code point  <a href="#aaba589becdcea269f271466f73dbf08b">More...</a><br /></td></tr>
<tr class="separator:aaba589becdcea269f271466f73dbf08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ae71e0b684c04b9f3e5c14e31af422"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a60ae71e0b684c04b9f3e5c14e31af422">token_type_name</a> (<a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7">token_type</a> t)</td></tr>
<tr class="memdesc:a60ae71e0b684c04b9f3e5c14e31af422"><td class="mdescLeft">&#160;</td><td class="mdescRight">return name of values of type token_type (only used for errors)  <a href="#a60ae71e0b684c04b9f3e5c14e31af422">More...</a><br /></td></tr>
<tr class="separator:a60ae71e0b684c04b9f3e5c14e31af422"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a74c75a6bcb1cbac21bb6f15ef57a5850"><td class="memItemLeft" align="right" valign="top">std::istream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a74c75a6bcb1cbac21bb6f15ef57a5850">m_stream</a> = nullptr</td></tr>
<tr class="memdesc:a74c75a6bcb1cbac21bb6f15ef57a5850"><td class="mdescLeft">&#160;</td><td class="mdescRight">optional input stream  <a href="#a74c75a6bcb1cbac21bb6f15ef57a5850">More...</a><br /></td></tr>
<tr class="separator:a74c75a6bcb1cbac21bb6f15ef57a5850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbbaf37fd7ec9d8c3b1ebafd51b4b8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#ab63e618bbb0371042b1bec17f5891f42">string_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a0fbbaf37fd7ec9d8c3b1ebafd51b4b8d">m_buffer</a></td></tr>
<tr class="memdesc:a0fbbaf37fd7ec9d8c3b1ebafd51b4b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the buffer  <a href="#a0fbbaf37fd7ec9d8c3b1ebafd51b4b8d">More...</a><br /></td></tr>
<tr class="separator:a0fbbaf37fd7ec9d8c3b1ebafd51b4b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45ff29cd065f678d9e0360ac73ca075"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a7858ae971d07f21ad47fa8a0421001db">lexer_char_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#ae45ff29cd065f678d9e0360ac73ca075">m_content</a> = nullptr</td></tr>
<tr class="memdesc:ae45ff29cd065f678d9e0360ac73ca075"><td class="mdescLeft">&#160;</td><td class="mdescRight">the buffer pointer  <a href="#ae45ff29cd065f678d9e0360ac73ca075">More...</a><br /></td></tr>
<tr class="separator:ae45ff29cd065f678d9e0360ac73ca075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb3cad57dba79e7474a51d9e542d841"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a7858ae971d07f21ad47fa8a0421001db">lexer_char_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a7bb3cad57dba79e7474a51d9e542d841">m_start</a> = nullptr</td></tr>
<tr class="memdesc:a7bb3cad57dba79e7474a51d9e542d841"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the beginning of the current symbol  <a href="#a7bb3cad57dba79e7474a51d9e542d841">More...</a><br /></td></tr>
<tr class="separator:a7bb3cad57dba79e7474a51d9e542d841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996cc0634a78006085d2e9a5c0c8ecb7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a7858ae971d07f21ad47fa8a0421001db">lexer_char_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a996cc0634a78006085d2e9a5c0c8ecb7">m_marker</a> = nullptr</td></tr>
<tr class="memdesc:a996cc0634a78006085d2e9a5c0c8ecb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer for backtracking information  <a href="#a996cc0634a78006085d2e9a5c0c8ecb7">More...</a><br /></td></tr>
<tr class="separator:a996cc0634a78006085d2e9a5c0c8ecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990b28993e1136d8a859ced7223ea592"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a7858ae971d07f21ad47fa8a0421001db">lexer_char_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a990b28993e1136d8a859ced7223ea592">m_cursor</a> = nullptr</td></tr>
<tr class="memdesc:a990b28993e1136d8a859ced7223ea592"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the current symbol  <a href="#a990b28993e1136d8a859ced7223ea592">More...</a><br /></td></tr>
<tr class="separator:a990b28993e1136d8a859ced7223ea592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a9a6d80fcbed465af205f643df5376"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a7858ae971d07f21ad47fa8a0421001db">lexer_char_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#ab9a9a6d80fcbed465af205f643df5376">m_limit</a> = nullptr</td></tr>
<tr class="memdesc:ab9a9a6d80fcbed465af205f643df5376"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the end of the buffer  <a href="#ab9a9a6d80fcbed465af205f643df5376">More...</a><br /></td></tr>
<tr class="separator:ab9a9a6d80fcbed465af205f643df5376"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt;<br />
class nlohmann::basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer</h3>

<p>lexical analysis </p>
<p>This class organizes the lexical analysis during JSON deserialization. The core of it is a scanner generated by <a href="http://re2c.org">re2c</a> that processes a buffer and recognizes tokens according to RFC 7159. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a7858ae971d07f21ad47fa8a0421001db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::<a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a7858ae971d07f21ad47fa8a0421001db">lexer::lexer_char_t</a> =  unsigned char</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the char type to use in the lexer </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a96887d6cd131e3d3a85a9d71fbdbcdf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7">nlohmann::basic_json::lexer::token_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>token types for the parser </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a96887d6cd131e3d3a85a9d71fbdbcdf7a42dd1a73d072bb6bf3f494f22b15db8e"></a>uninitialized&#160;</td><td class="fielddoc">
<p>indicating the scanner is uninitialized </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96887d6cd131e3d3a85a9d71fbdbcdf7a85cc1a37b0aaa52de40e72f0ed4e0c0d"></a>literal_true&#160;</td><td class="fielddoc">
<p>the "true" literal </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96887d6cd131e3d3a85a9d71fbdbcdf7afab1694b1b3937a079f4625fe0b6108b"></a>literal_false&#160;</td><td class="fielddoc">
<p>the "false" literal </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96887d6cd131e3d3a85a9d71fbdbcdf7ab7ae4c0e46d86f884677768160b26e9e"></a>literal_null&#160;</td><td class="fielddoc">
<p>the "null" literal </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96887d6cd131e3d3a85a9d71fbdbcdf7a2b490e8bf366b4cbe3ebd99b26ce15ce"></a>value_string&#160;</td><td class="fielddoc">
<p>a string &ndash; use <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a18dc059f3a96af88104ca02d919c16b5" title="return string value for string tokens ">get_string()</a> for actual value </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96887d6cd131e3d3a85a9d71fbdbcdf7a70757c72c4d12f142689024dc4acb9dd"></a>value_number&#160;</td><td class="fielddoc">
<p>a number &ndash; use <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a3a9787fee5177c60bbc80d9e41282e9f" title="return number value for number tokens ">get_number()</a> for actual value </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96887d6cd131e3d3a85a9d71fbdbcdf7a16c226b4425b68560fea322b46dabe01"></a>begin_array&#160;</td><td class="fielddoc">
<p>the character for array begin "[" </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96887d6cd131e3d3a85a9d71fbdbcdf7a9a9ffd53b6869d4eca271b1ed5b57fe8"></a>begin_object&#160;</td><td class="fielddoc">
<p>the character for object begin "{" </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96887d6cd131e3d3a85a9d71fbdbcdf7a2f3e68e7f111a1e5c7728742b3ca2b7f"></a>end_array&#160;</td><td class="fielddoc">
<p>the character for array end "]" </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96887d6cd131e3d3a85a9d71fbdbcdf7a7d5b4427866814de4d8f132721d59c87"></a>end_object&#160;</td><td class="fielddoc">
<p>the character for object end "}" </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96887d6cd131e3d3a85a9d71fbdbcdf7acc3c64f8ae08c00de1b33f19a4d2913a"></a>name_separator&#160;</td><td class="fielddoc">
<p>the name separator ":" </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96887d6cd131e3d3a85a9d71fbdbcdf7a745373036100d7392ad62c617cab59af"></a>value_separator&#160;</td><td class="fielddoc">
<p>the value separator "," </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96887d6cd131e3d3a85a9d71fbdbcdf7a456e19aeafa334241c7ff3f589547f9d"></a>parse_error&#160;</td><td class="fielddoc">
<p>indicating a parse error </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96887d6cd131e3d3a85a9d71fbdbcdf7aca11f56dd477c09e06583dbdcda0985f"></a>end_of_input&#160;</td><td class="fielddoc">
<p>indicating the end of the input buffer </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4b09fcd209c514976c530257f092bcd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::lexer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html#ab63e618bbb0371042b1bec17f5891f42">string_t</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor with a given buffer </p>

</div>
</div>
<a class="anchor" id="a7750487ca3688d91c31d87c7e7917ee0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::lexer </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor with a given stream </p>

</div>
</div>
<a class="anchor" id="acd79b7df4a2c6b3693648b18ce4c359c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::lexer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default constructor </p>

</div>
</div>
<a class="anchor" id="a18cd0b0203240c650de724eaa372fe20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::lexer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html">lexer</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3a9787fee5177c60bbc80d9e41282e9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::get_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return number value for number tokens </p>
<p>This function translates the last token into the most appropriate number type (either integer, unsigned integer or floating point), which is passed back to the caller via the result parameter.</p>
<p>This function parses the integer component up to the radix point or exponent while collecting information about the 'floating point representation', which it stores in the result parameter. If there is no radix point or exponent, and the number can fit into a <a class="el" href="classnlohmann_1_1basic__json.html#ac4b10b2364f26ce47bdb9a413ff04a59">number_integer_t</a> or <a class="el" href="classnlohmann_1_1basic__json.html#a60a04166c122072ab11eaf9845d9cd1d">number_unsigned_t</a> then it sets the result parameter accordingly.</p>
<p>The 'floating point representation' includes the number of significant figures after the radix point, whether the number is in exponential or decimal form, the capitalization of the exponent marker, and if the optional '+' is present in the exponent. This information is necessary to perform accurate round trips of floating point numbers.</p>
<p>If the number is a floating point number the number is then parsed using <em>std:strtod</em> (or <em>std:strtof</em> or <em>std::strtold</em>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> object to receive the number, or NAN if the conversion read past the current token. The latter case needs to be treated by the caller function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18dc059f3a96af88104ca02d919c16b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#ab63e618bbb0371042b1bec17f5891f42">string_t</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::get_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return string value for string tokens </p>
<p>The function iterates the characters between the opening and closing quotes of the string value. The complete string is the range [m_start,m_cursor). Consequently, we iterate from m_start+1 to m_cursor-1.</p>
<p>We differentiate two cases:</p>
<ol type="1">
<li>Escaped characters. In this case, a new character is constructed according to the nature of the escape. Some escapes create new characters (e.g., <code>"\\\\n"</code> is replaced by <code>"\\n"</code>), some are copied as is (e.g., <code>"\\\\\\\\"</code>). Furthermore, Unicode escapes of the shape <code>"\\\\uxxxx"</code> need special care. In this case, to_unicode takes care of the construction of the values.</li>
<li>Unescaped characters are copied as is.</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>string value of current token without opening and closing quotes </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if to_unicode fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0eab4ce848cefe355dd0d61f9a5348a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#ab63e618bbb0371042b1bec17f5891f42">string_t</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::get_token </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return string representation of last read token </p>

</div>
</div>
<a class="anchor" id="a862a22693d9fadbf4a5f00207da1dd00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html">lexer</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html">lexer</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a196879de6f3e59c98e2362fb8d401dc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7">token_type</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::scan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function implements a scanner for JSON. It is specified using regular expressions that try to follow RFC 7159 as close as possible. These regular expressions are then translated into a minimized deterministic finite automaton (DFA) by the tool <a href="http://re2c.org">re2c</a>. As a result, the translated code for this function consists of a large block of code with <code>goto</code> jumps.</p>
<dl class="section return"><dt>Returns</dt><dd>the class of the next token read from the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a541f1cd06178fefc5ddde34022852c10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long double <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::str_to_float_t </td>
          <td>(</td>
          <td class="paramtype">long double *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parse floating point number </p>
<p>This function (and its overloads) serves to select the most approprate standard floating point number parsing function based on the type supplied via the first parameter. Set this to <em>static_cast&lt;number_float_t*&gt;(nullptr)</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>the <a class="el" href="classnlohmann_1_1basic__json.html#a74a0013e847fdc574b48f931f0e757e1">number_float_t</a> in use</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">endptr</td><td>recieves a pointer to the first character after the number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floating point number</dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>This function uses <code>std::strtof</code>, <code>std::strtod</code>, or <code>std::strtold</code> which use the current C locale to determine which character is used as decimal point character. This may yield to parse errors if the locale does not used <code>.</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a29d53d1c76a58b7f4d1315d44665eab3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::str_to_float_t </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parse floating point number </p>
<p>This function (and its overloads) serves to select the most approprate standard floating point number parsing function based on the type supplied via the first parameter. Set this to <em>static_cast&lt;number_float_t*&gt;(nullptr)</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>the <a class="el" href="classnlohmann_1_1basic__json.html#a74a0013e847fdc574b48f931f0e757e1">number_float_t</a> in use</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">endptr</td><td>recieves a pointer to the first character after the number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floating point number </dd></dl>

</div>
</div>
<a class="anchor" id="aea092725cd2b01e84126898f080418d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::str_to_float_t </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parse floating point number </p>
<p>This function (and its overloads) serves to select the most approprate standard floating point number parsing function based on the type supplied via the first parameter. Set this to <em>static_cast&lt;number_float_t*&gt;(nullptr)</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>the <a class="el" href="classnlohmann_1_1basic__json.html#a74a0013e847fdc574b48f931f0e757e1">number_float_t</a> in use</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">endptr</td><td>recieves a pointer to the first character after the number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floating point number </dd></dl>

</div>
</div>
<a class="anchor" id="aaba589becdcea269f271466f73dbf08b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classnlohmann_1_1basic__json.html#ab63e618bbb0371042b1bec17f5891f42">string_t</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::to_unicode </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>codepoint1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>codepoint2</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a string from a Unicode code point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codepoint1</td><td>the code point (can be high surrogate) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">codepoint2</td><td>the code point (can be low surrogate or 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string representation of the code point</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if code point is &gt; 0x10ffff; example: <code>"code
points above 0x10FFFF are invalid"</code> </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the low surrogate is invalid; example: <code>""missing or wrong low surrogate""</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.wikipedia.org/wiki/UTF-8#Sample_code">http://en.wikipedia.org/wiki/UTF-8#Sample_code</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a60ae71e0b684c04b9f3e5c14e31af422"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::token_type_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a96887d6cd131e3d3a85a9d71fbdbcdf7">token_type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return name of values of type token_type (only used for errors) </p>

</div>
</div>
<a class="anchor" id="a8b7f5e914691aaa545ad291eb5ddc817"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::yyfill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>append data from the stream to the internal buffer </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a0fbbaf37fd7ec9d8c3b1ebafd51b4b8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#ab63e618bbb0371042b1bec17f5891f42">string_t</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::m_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the buffer </p>

</div>
</div>
<a class="anchor" id="ae45ff29cd065f678d9e0360ac73ca075"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a7858ae971d07f21ad47fa8a0421001db">lexer_char_t</a>* <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::m_content = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the buffer pointer </p>

</div>
</div>
<a class="anchor" id="a990b28993e1136d8a859ced7223ea592"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a7858ae971d07f21ad47fa8a0421001db">lexer_char_t</a>* <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::m_cursor = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer to the current symbol </p>

</div>
</div>
<a class="anchor" id="ab9a9a6d80fcbed465af205f643df5376"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a7858ae971d07f21ad47fa8a0421001db">lexer_char_t</a>* <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::m_limit = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer to the end of the buffer </p>

</div>
</div>
<a class="anchor" id="a996cc0634a78006085d2e9a5c0c8ecb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a7858ae971d07f21ad47fa8a0421001db">lexer_char_t</a>* <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::m_marker = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer for backtracking information </p>

</div>
</div>
<a class="anchor" id="a7bb3cad57dba79e7474a51d9e542d841"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnlohmann_1_1basic__json_1_1lexer.html#a7858ae971d07f21ad47fa8a0421001db">lexer_char_t</a>* <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::m_start = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer to the beginning of the current symbol </p>

</div>
</div>
<a class="anchor" id="a74c75a6bcb1cbac21bb6f15ef57a5850"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename...Args &gt; class ObjectType = std::map, template&lt; typename U, typename...Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream* <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType &gt;::lexer::m_stream = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>optional input stream </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lib/serializer/<a class="el" href="json_8h_source.html">json.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
